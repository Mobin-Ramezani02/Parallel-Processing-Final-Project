from fastapi import FastAPI, Query
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse


from Threads.question1 import run_thread_question_1
from Threads.question2 import run_thread_question_2
from Threads.question3 import run_thread_question_3
from Threads.question4 import run_thread_question_4
from Threads.question5 import run_thread_question_5
from Threads.question6 import run_thread_question_6
from Threads.question7 import run_thread_question_7

from Processes.question1 import run_process_question_1
from Processes.question2 import run_process_question_2
from Processes.question3 import run_process_question_3
from Processes.question4 import run_process_question_4
from Processes.question5 import run_process_question_5
from Processes.question6 import run_process_question_6
from Processes.question7 import run_process_question_7
from Processes.question8 import run_process_question_8

app = FastAPI()

app.mount("/static", StaticFiles(directory="static"), name="static")

@app.get("/")
def index():
    return FileResponse("static/index.html")


EXPLANATIONS_THREAD = {
    (1, "1"): "در این برنامه تابع my_func توسط ۱۰ نخ مختلف (N0 تا N9) فراخوانی می شود. هر نخ یک شماره منحصر به ‌فرد دریافت کرده و آن را چاپ می‌کند. استفاده از threading.Thread باعث می شود تمام نخ‌ها تقریباً همزمان شروع شوند، اما چون کار هر نخ فقط یک دستور چاپ است و هیچ منبع مشترکی تغییر داده نمی‌شود، هیچ شرایط رقابتی به وجود نمی‌آید و خروجی درست و کامل تولید می‌شود. دستور join() تضمین می‌کند که برنامه اصلی منتظر بماند تا همه نخ‌ها کارشان تمام شود. ترتیب چاپ می‌تواند در اجراهای مختلف تغییر کند (به دلیل زمان‌بندی سیستم‌عامل)، اما در این مثال چون کار سبک است معمولاً خروجی به ترتیب N0 تا N9 دیده می‌شود. بنابراین علت خروجی منظم مشاهده‌شده، سادگی وظیفه و کوتاه بودن زمان اجرای هر نخ است.",
    (1, "2"): "در این برنامه تابع my_func در یک حلقه‌ی ۱۰ بار توسط نخ‌های مختلف اجرا می‌شود. در هر تکرار، یک نخ جدید ساخته می‌شود، شروع به کار می‌کند و بلافاصله با دستور join() منتظر می‌مانیم تا اجرای آن نخ کامل شود. به همین دلیل نخ‌ها پشت سر هم و به‌صورت ترتیبی اجرا می‌شوند و نتیجه به‌صورت منظم از N0 تا N9 چاپ می‌شود. علت این خروجی منظم، قرار گرفتن دستور join() در داخل حلقه است که باعث می‌شود قبل از شروع نخ بعدی، نخ قبلی کاملاً تمام شده باشد.",
    (1, "3"): "در این برنامه برای هر مقدار n یک نخ ساخته می‌شود که ابتدا به‌مدت تصادفی بین 0.1 تا 1 ثانیه می‌خوابد (time.sleep(random.uniform(0.1, 1))) و بعد پیام خود را چاپ می‌کند. چون تأخیر هر نخ متفاوت و زمان‌بندی اجرای نخ‌ها غیرقطعی است، ترتیب چاپ پیام‌ها ثابت نیست و در هر اجرا می‌تواند عوض شود؛ خروجیِ دیده‌شده حاصل همین تأخیرهای تصادفی و زمان‌بندی سیستم است. از آن‌جا که در پایان حلقه، نخ‌ها join نمی‌شوند و فقط نخ اصلی 3 ثانیه می‌خوابد، عملاً به همه‌ی نخ‌ها فرصت پایان‌دادن داده می‌شود؛ با توجه به اینکه بیشینه‌ی تأخیر هر نخ حدود 1 ثانیه است، همه‌ی پیام‌ها پیش از بیدارشدن نخ اصلی چاپ می‌شوند. بنابراین علت ترتیب نامنظم، خواب تصادفی هر نخ و نبودِ همگام‌سازی صریح، و علت کامل‌بودن خروجی، زمان ۳ ثانیه‌ای نخ اصلی است.",
    (2, "1"): "در این برنامه سه نخ به نام‌های function_A، function_B و function_C ایجاد می‌شوند. هر نخ هنگام شروع پیام «starting» را چاپ می‌کند، سپس مدتی تصادفی بین 0.1 تا 1 ثانیه متوقف می‌شود و در پایان پیام «exiting» را نمایش می‌دهد. به دلیل تصادفی بودن زمان خواب و همچنین زمان‌بندی سیستم‌عامل، ترتیب چاپ پیام‌ها در هر اجرا می‌تواند متفاوت باشد. استفاده از دستور join() باعث می‌شود برنامه اصلی منتظر بماند تا همه‌ی نخ‌ها کارشان را تمام کنند و هیچ پیامی از دست نرود. علت خروجی، اجرای موازی نخ‌ها با تأخیرهای تصادفی و هماهنگ‌سازی نهایی با join() است.",
    (2, "2"): "در این برنامه سه نخ تعریف شده است، اما اجرای آن‌ها به‌صورت ترتیبی انجام می‌شود. ابتدا نخ function_A آغاز می‌شود، پیام شروع را چاپ می‌کند، مدت کوتاهی به‌طور تصادفی می‌خوابد و سپس پیام پایان را چاپ می‌کند. به‌دلیل قرار گرفتن join() بلافاصله بعد از start()، برنامه اصلی منتظر می‌ماند تا اجرای این نخ تمام شود و بعد به سراغ نخ بعدی برود. همین روند برای function_B و سپس function_C تکرار می‌شود. در نتیجه خروجی همیشه منظم و پشت سر هم است و اجرای همزمان واقعی بین نخ‌ها اتفاق نمی‌افتد. علت این خروجی، استفاده از join() در داخل هر مرحله و اجرای سریالی نخ‌ها است.",
    (2, "3"): "در این برنامه سه نخ به نام‌های function_A، function_B و function_C ساخته و تقریباً همزمان شروع می‌شوند. هر نخ پس از چاپ پیام «starting»، به‌مدت تصادفی بین 0.1 تا 1 ثانیه متوقف می‌شود و سپس پیام «exiting» را چاپ می‌کند. ترتیب شروع معمولاً همان ترتیب start() است، اما ترتیب پایان به زمان خواب هر نخ و زمان‌بندی سیستم بستگی دارد و می‌تواند در هر اجرا متفاوت باشد. از آن‌جا که در پایان حلقه به جای join() از time.sleep(5) استفاده شده، نخ اصلی فقط پنج ثانیه منتظر می‌ماند و این زمان از بیشترین خواب نخ‌ها بیشتر است، بنابراین همه‌ی نخ‌ها فرصت می‌کنند اجرای خود را کامل کنند. علت خروجی، اجرای موازی نخ‌ها با تأخیرهای تصادفی و پایان‌دهی برنامه اصلی پس از گذشت زمان کافی است.",
    (3, "1"): "در این برنامه یک کلاس نخ سفارشی به نام MyThread تعریف شده است که هنگام اجرا ابتدا پیام «running» همراه با شماره نخ و شناسه پردازه را چاپ می‌کند، سپس به‌مدت تصادفی بین 0.1 تا 1 ثانیه متوقف می‌شود و در پایان پیام «over» را نمایش می‌دهد. همه‌ی نخ‌ها در یک حلقه ساخته و تقریباً همزمان با start() آغاز می‌شوند. به همین دلیل، پیام‌های شروع آن‌ها پشت سر هم ظاهر می‌شود، ولی زمان پایان هر نخ به تأخیر تصادفی و زمان‌بندی سیستم بستگی دارد و ترتیب ثابتی ندارد. استفاده از join() روی همه نخ‌ها باعث می‌شود برنامه اصلی منتظر بماند تا همه‌ی نخ‌ها کارشان را تمام کنند، سپس پیام «End» و زمان کل اجرا چاپ شود. علت این خروجی، اجرای موازی نخ‌ها با مدت خواب متفاوت و همگام‌سازی نهایی با join() است.",
    (3, "2"): "در این برنامه یک کلاس نخ سفارشی تعریف شده است که هنگام اجرا پیام شروع و پایان نخ را همراه با شناسه پردازه چاپ می‌کند. تفاوت اصلی در این است که هر نخ بلافاصله بعد از ساخته‌شدن با start() آغاز می‌شود و سپس با join() منتظر می‌مانیم تا همان نخ کارش تمام شود. به این ترتیب نخ‌ها یکی‌یکی و به‌صورت ترتیبی اجرا می‌شوند، نه همزمان. چون هر نخ مدت تصادفی بین 0.1 تا 1 ثانیه می‌خوابد، مجموع زمان اجرای کل برنامه تقریباً برابر جمع همه‌ی این توقف‌ها است (چند ثانیه). علت این خروجی، قرار گرفتن دستور join() داخل حلقه است که باعث می‌شود قبل از شروع نخ بعدی، نخ قبلی کاملاً پایان یافته باشد و اجرای موازی رخ ندهد.",
    (3, "3"): "در این برنامه ۹ نخ از کلاس MyThread ساخته می‌شود که هرکدام نام یکتای خود را چاپ می‌کنند، سپس دقیقاً ۱ ثانیه می‌خوابند و در پایان «over» را چاپ می‌کنند. همه‌ی نخ‌ها ابتدا در یک حلقه شروع می‌شوند و بعد در حلقه‌ی جداگانه با join() منتظر اتمامشان می‌مانیم؛ بنابراین خواب ۱‌ثانیه‌ای آن‌ها به‌طور همپوشان انجام می‌شود. به همین دلیل زمان کل برنامه حدود ۱ ثانیه (به‌علاوه‌ی اندکی سربار زمان‌بندی و چاپ) است. ترتیب پیام‌های «over» ممکن است کمی جابه‌جا شود، چون بیدارشدن و زمان‌بندی نخ‌ها غیرقطعی است، اما همگی قبل از چاپ «End» تمام می‌شوند. چاپ یکسان process ID نشان می‌دهد همه‌ی نخ‌ها به یک پردازه تعلق دارند. علت الگوی خروجی، شروع همزمان نخ‌ها با مدت خواب ثابت و همگام‌سازی نهایی با join() است.",
    (4, "1"): "در این برنامه برای هر نخ تابع thread_task اجرا می‌شود که ابتدا پیام شروع را چاپ می‌کند، سپس به‌مدت تصادفی بین 0.5 تا 1.5 ثانیه می‌خوابد و در نهایت پیام پایان را چاپ می‌کند. نکته مهم این است که کل این بخش داخل with lock: قرار دارد، یعنی هر بار فقط یک نخ اجازه دارد وارد این بخش شود و بقیه باید منتظر بمانند. در نتیجه نخ‌ها عملاً به‌صورت سریالی اجرا می‌شوند و مدت زمان کل اجرای برنامه تقریباً برابر مجموع زمان خواب همه نخ‌ها (حدود چندین ثانیه) است. ترتیب اجرای نخ‌ها بستگی به زمان‌بندی دارد اما در هر لحظه فقط یک نخ در حال اجراست. علت خروجی طولانی و ترتیبی، استفاده از قفل مشترک (Lock) است که موازی‌سازی را از بین برده و نخ‌ها را پشت سر هم اجرا می‌کند.",
    (4, "2"): "در این برنامه برای هر مقدار i یک نخ ساخته می‌شود، فوراً با start() اجرا می‌گردد و همان‌جا با join() منتظر می‌مانیم تا کار همان نخ تمام شود. کل کار هر نخ (چاپ «starting»، sleep تصادفی بین 0.5 تا 1.5 ثانیه، و چاپ «over») داخل with lock: انجام می‌شود؛ یعنی هم‌زمان فقط همان نخ اجازه‌ی اجرا در این بخش را دارد. به‌خاطر قرار گرفتن join() در داخل حلقه و وجود lock روی کل کار، اجرای نخ‌ها عملاً کاملاً ترتیبی است. بنابراین خروجی به‌صورت جفت‌های پشت‌سرهم «starting/over» برای هر نخ دیده می‌شود و زمان کل تقریباً برابر جمع زمان‌های خواب نخ‌ها (به‌علاوه‌ی اندکی سربار چاپ و زمان‌بندی) است. علت این الگو، انتظار دادن بعد از هر start() و محافظت قفلی کل بخش اجرا است که موازی‌سازی را حذف کرده است.",
    (4, "3"): "در این برنامه ۹ نخ ایجاد و همگی شروع می‌شوند، اما کل کار هر نخ داخل with lock: انجام می‌شود. هر نخ وقتی قفل را می‌گیرد، «starting» را چاپ می‌کند، به‌مدت ۱ ثانیه در حالی‌که قفل را نگه داشته می‌خوابد، سپس «over» را چاپ کرده و قفل را آزاد می‌کند. چون قفل کل بخش را پوشش می‌دهد، در هر لحظه فقط یک نخ می‌تواند این بخش را اجرا کند و بقیه پشت قفل منتظر می‌مانند؛ بنابراین اجرا عملاً سریالی است. در پایان، با join() روی همه‌ی نخ‌ها منتظر می‌مانیم تا همگی تمام شوند و بعد «End» و زمان کل چاپ می‌شود. با توجه به خواب ۱ ثانیه‌ای هر نخ و ۹ نخ، زمان کل تقریباً برابر ۹ ثانیه (به‌علاوه‌ی اندکی سربار) است.",
    (5, "1"): "در این برنامه یک شیء Box با شمارنده‌ی مشترک total_items و قفلِ بازگشتی threading.RLock() ساخته می‌شود. هر بار که add() یا remove() فراخوانی می‌شود، همان نخ ابتدا قفل را می‌گیرد و سپس داخل همان بخشِ محافظت‌شده، متد execute() را که خودش نیز قفل می‌گیرد صدا می‌زند؛ به‌خاطر بازگشتی‌بودن RLock، قفل دوباره توسط همان نخ بدون انسداد گرفته می‌شود و به این ترتیب افزایش/کاهش شمارنده اتمی و ایمن انجام می‌شود. دو نخ همزمان اجرا می‌شوند: adder به‌اندازه‌ی items_to_add با وقفه‌ی کوتاه (sleep(0.1)) یک‌به‌یک آیتم اضافه می‌کند و بعد از هر بار، مقدار فعلی total_items را چاپ می‌کند؛ remover نیز به‌اندازه‌ی items_to_remove یک‌به‌یک کم می‌کند و مقدار به‌روز را چاپ می‌کند. وقفه‌های کوتاه و زمان‌بندی سیستم باعث درهم‌تنیدگی پیام‌ها می‌شوند، اما چون هر به‌روزرسانی پشت قفل انجام می‌شود، شمارنده هر بار دقیقاً یک واحد تغییر می‌کند و خطای رقابتی رخ نمی‌دهد. نتیجه‌ی منطقی اجرا، برابر شدن مقدار نهایی با تفاوت بین تعداد اضافه‌کردن‌ها و کم‌کردن‌هاست.",
    (5, "2"): "در این برنامه یک شیء Box با شمارنده‌ی مشترک total_items و قفل بازگشتی threading.RLock() تعریف شده است. نخ adder ابتدا به‌طور کامل اجرا می‌شود و بعد از اتمام آن (به‌دلیل قرار گرفتن t1.join() بلافاصله پس از t1.start())، نخ remover شروع می‌شود؛ بنابراین اجرای دو نخ ترتیبی است. هر بار افزایش/کاهش داخل with self.lock: انجام می‌شود و متد execute() نیز همان قفل را دوباره می‌گیرد؛ چون قفل از نوع بازگشتی (RLock) است، گرفتنِ مجدد قفل توسط همان نخ باعث انسداد نمی‌شود و به‌روزرسانی‌ها اتمی و ایمن انجام می‌گیرند. در نتیجه ابتدا شمارنده در adder یک‌به‌یک زیاد می‌شود و سپس در remover یک‌به‌یک کم می‌شود؛ بدون هیچ درهم‌تنیدگی چاپ‌ها یا شرایط رقابتی. مقدار نهایی به‌صورت منطقی برابر اختلاف تعداد افزودن‌ها و کاستن‌هاست (اینجا 16−5).",
    (5, "3"): "در این برنامه دو نخ adder و remover هم‌زمان شروع می‌شوند و هرکدام در یک حلقه، با وقفه‌ی کوتاه sleep(0.1)، شمارنده‌ی مشترک total_items را یک‌به‌یک زیاد یا کم می‌کنند. هر به‌روزرسانی داخل with self.lock: و سپس در متد execute() که همان قفل بازگشتی RLock را دوباره می‌گیرد انجام می‌شود؛ بنابراین هر بار تغییر شمارنده اتمی و ایمن است و شرایط رقابتی رخ نمی‌دهد. به‌خاطر اجرای هم‌زمان و وقفه‌های کوتاه، پیام‌های «ADDED…» و «REMOVED…» به‌صورت درهم‌تنیده چاپ می‌شوند. ترتیب t2.join() و سپس t1.join() فقط باعث می‌شود نخ اصلی منتظر بماند تا هر دو نخ تمام شوند؛ این ترتیب هیچ تاثیری بر ترتیب اجرای واقعی دو نخ ندارد. نتیجه‌ی منطقی اجرا برابر با اختلاف تعداد افزودن‌ها و کاستن‌هاست و همه‌ی چاپ‌ها قبل از پایان برنامه نمایش داده می‌شوند.",
    (6, "1"): "در این کد الگوی «تولیدکننده–مصرف‌کننده» با سمافور پیاده شده است. نخ مصرف‌کننده ابتدا پیام «waiting» را چاپ کرده و روی سمافور متوقف می‌شود. تولیدکننده پس از کمی تأخیر عددی تصادفی در متغیر item قرار می‌دهد، پیام «Producer notify» را چاپ کرده و با semaphore.release() مصرف‌کننده را آزاد می‌کند. سپس مصرف‌کننده همان مقدار را می‌خواند و «Consumer notify» را چاپ می‌کند. استفاده از سمافور باعث هماهنگی دقیق بین این دو نخ می‌شود و چون در هر حلقه نخ‌ها join می‌شوند، هر جفت تولید–مصرف کامل اجرا شده و سپس جفت بعدی آغاز می‌شود.",
    (6, "2"): "در این کد ۱۰ نخ «مصرف‌کننده» و ۱۰ نخ «تولیدکننده» ساخته می‌شود. همه‌ی مصرف‌کننده‌ها بلافاصله پیام «waiting» را ثبت کرده و روی Semaphore(0) مسدود می‌شوند. همه‌ی تولیدکننده‌ها نیز با هم شروع می‌شوند، پس از 1.5s عددی تصادفی را در متغیر مشترک item می‌نویسند و با semaphore.release() یکی از مصرف‌کننده‌ها را آزاد می‌کنند. هر release دقیقاً یک مصرف‌کننده را از acquire عبور می‌دهد، بنابراین به تعداد تولیدها مصرف هم انجام می‌شود. توجه اینکه سمافور فقط هماهنگ‌سازی رویداد را تضمین می‌کند و از درستی داده محافظت نمی‌کند؛ چون item بدون قفل به‌روزرسانی می‌شود، هر مصرف‌کننده مقدار «در لحظه‌ی بیدارشدن» را می‌خواند و ترتیب جفت‌شدن مقدارها غیردترمینستیک است. در انتها با join() منتظر پایان همه‌ی نخ‌ها می‌مانیم، لذا لاگ همه‌ی اعلان‌ها ثبت می‌شود.",
    (6, "3"): "در این کد ۱۰ «مصرف‌کننده» و ۱۰ «تولیدکننده» همزمان استارت می‌شوند. هر مصرف‌کننده بلافاصله «waiting» را لاگ می‌کند و روی Semaphore(0) بلوکه می‌شود. هر تولیدکننده پس از 1.5s عددی تصادفی را در متغیر مشترک item می‌نویسد، «Producer notify» را لاگ می‌کند و با semaphore.release() یک مصرف‌کننده را آزاد می‌کند. چون از سمافور فقط برای هماهنگ‌سازی استفاده شده و item بدون قفل مشترک است، هر مصرف‌کننده هنگام بیدار شدن آخرین مقدارِ ثبت‌شده در item تا همان لحظه را می‌خواند؛ بنابراین تطابق «producer/consumer» لزوماً یک‌به‌یک نیست و ممکن است چند مصرف‌کننده یک مقدار یکسان را گزارش کنند. نبود join() باعث می‌شود نخ اصلی فقط با sleep(10) فرصت کافی برای اتمام همه‌ی نخ‌ها بدهد.",
    (7, "1"): "در این برنامه یک مانع (Barrier) با ظرفیت ۳ نخ تعریف شده است. هر نخ با نام مشخص شده ابتدا مدتی تصادفی می‌خوابد و سپس زمان رسیدن خود را چاپ می‌کند. وقتی هر سه نخ به مانع برسند، barrier.wait() آن‌ها را همزمان آزاد می‌کند و ادامه‌ی برنامه اجرا می‌شود. به همین دلیل همه‌ی نخ‌ها پس از چاپ پیام رسیدن، تقریباً همزمان از مانع عبور می‌کنند و در پایان پیام «Race over!» بعد از اتمام همه نخ‌ها نمایش داده می‌شود. علت این الگو، استفاده از Barrier برای هماهنگ‌سازی همزمان سه نخ است.",
    (7, "2"): "در این برنامه سه نخ به‌طور همزمان ساخته می‌شوند و بلافاصله پیام رسیدن به مانع را چاپ می‌کنند. سپس هر سه نخ روی barrier.wait() متوقف می‌شوند تا همه به مانع برسند. وقتی هر سه نخ حاضر شدند، مانع آزاد می‌شود و همگی به‌طور هماهنگ ادامه می‌دهند. در پایان پس از اتمام همه نخ‌ها، پیام «Race over!» چاپ می‌شود. علت خروجی هماهنگ و همزمان، استفاده از Barrier(3) است که تا رسیدن همه نخ‌ها اجازه‌ی ادامه نمی‌دهد.",
    (7, "3"): "در این برنامه سه نخ ساخته می‌شوند و هرکدام پس از یک تأخیر تصادفی پیام رسیدن به مانع را چاپ می‌کنند. سپس روی barrier.wait() متوقف می‌شوند تا همه به مانع برسند و همزمان آزاد شوند. برخلاف نسخه‌های قبلی از join() استفاده نشده و فقط نخ اصلی با sleep(5) منتظر می‌ماند؛ بنابراین پیام «Race over!» صرفاً بعد از گذشت این زمان چاپ می‌شود، نه الزاماً بعد از اتمام همه نخ‌ها. علت خروجی این است که Barrier هماهنگی رسیدن نخ‌ها را تضمین می‌کند، ولی نبود join() باعث می‌شود پایان کار نخ‌ها به‌طور کامل توسط نخ اصلی مدیریت نشود.",

}


EXPLANATIONS_PROCESS = {
    (1, "1"): "در این کد چند فرایند به طور همزمان ایجاد و اجرا می‌شوند. هر فرایند ابتدا پیامی مبنی بر شروع اجرای خود در صف قرار می‌دهد و سپس مقادیر شمارشی‌اش را یکی‌یکی اضافه می‌کند. از آنجا که فرایندها موازی هستند، پیام‌ها به صورت درهم‌تنیده وارد صف می‌شوند و نظم ثابتی ندارند. در انتها، برنامه‌ی اصلی پس از پایان همه فرایندها، صف را تخلیه و چاپ می‌کند؛ بنابراین همه خروجی‌ها دیده می‌شوند، اما ترتیب کلی آن‌ها وابسته به زمان‌بندی سیستم‌عامل است.",
    (1, "2"): "در این کد چند فرایند به طور همزمان اجرا می‌شوند. هر فرایند در ابتدا پیام شروع خود را در صف قرار می‌دهد و سپس مقادیر شمارشی را اضافه می‌کند. درون حلقه‌ی هر فرایند یک تأخیر تصادفی کوتاه قرار داده شده است، بنابراین تولید پیام‌ها با فاصله‌ی زمانی انجام می‌شود و در نتیجه خروجی‌ها بیشتر در هم تنیده می‌شوند. در نهایت برنامه‌ی اصلی پس از پایان همه فرایندها، پیام‌های موجود در صف را چاپ می‌کند؛ بنابراین تمام خروجی‌ها نمایش داده می‌شوند، اما ترتیب آن‌ها به دلیل تأخیرهای تصادفی و زمان‌بندی سیستم‌عامل قابل پیش‌بینی نیست.",
    (1, "3"): "در این کد چند فرایند ایجاد می‌شوند اما هر فرایند بلافاصله پس از شروع با دستور join() منتظر می‌ماند تا کارش کامل شود و سپس فرایند بعدی اجرا می‌شود. در نتیجه اجرای فرایندها به صورت ترتیبی انجام می‌گیرد و خروجی‌های مربوط به هر فرایند پشت سر هم و بدون درهم‌تنیدگی چاپ می‌شوند. بنابراین نظم خروجی‌ها حفظ می‌شود و هر بخش از نتایج مربوط به یک فرایند مشخص است.",
    (2, "1"): "در این کد چند فرایند به صورت همزمان شروع می‌شوند. هر فرایند در ابتدای اجرا پیام «Starting …» را در صف قرار می‌دهد، مدتی ثابت (۰٫۵ ثانیه) می‌خوابد و سپس پیام «Exiting …» را می‌گذارد. چون همه فرایندها موازی هستند، پیام‌های شروع تقریباً پشت سر هم ظاهر می‌شوند و پیام‌های پایان بسته به زمان‌بندی سیستم ممکن است به ترتیب متفاوتی چاپ شوند. علت این الگو اجرای همزمان فرایندها و چاپ خروجی‌ها از طریق صف مشترک است.",
    (2, "2"): "در این کد چند فرایند همزمان شروع می‌شوند و هر فرایند یک پیام «Starting …» در صف قرار می‌دهد، سپس برای مدت تصادفی کوتاهی متوقف می‌شود و در پایان پیام «Exiting …» را ثبت می‌کند. به دلیل این تأخیرهای تصادفی، ترتیب چاپ پیام‌های شروع و پایان در هر اجرا متفاوت است و خروجی‌ها به شکل درهم‌تنیده دیده می‌شوند. علت این رفتار، اجرای موازی فرایندها همراه با وقفه‌ی تصادفی درون هر فرایند است.",
    (2, "3"): "در این کد هر فرایند به صورت ترتیبی اجرا می‌شود؛ یعنی بعد از start() بلافاصله join() فراخوانی شده و تا پایان همان فرایند منتظر می‌ماند. بنابراین پیام «Starting …» و «Exiting …» مربوط به هر فرایند پشت سر هم و بدون تداخل با فرایندهای دیگر چاپ می‌شوند. علت این خروجی، اجرای سریالی فرایندها و جلوگیری از هم‌پوشانی در زمان‌بندی است.",
    (3, "1"): "در این کد تنها یک فرایند غیرزمینه‌ای اجرا می‌شود. این فرایند در ابتدا پیام شروع خود را چاپ کرده، سپس مقادیر ۵ تا ۹ را با تأخیر ثابت تولید می‌کند و در پایان پیام خروج را نمایش می‌دهد. چون فقط همین فرایند فعال است، خروجی پشت سر هم و بدون تداخل با فرایند دیگری چاپ شده است. علت این الگو اجرای ترتیبی و اختصاصی همان فرایند غیرزمینه‌ای است.",
    (3, "2"): "در این کد دو فرایند به طور همزمان اجرا می‌شوند: یکی زمینه‌ای و دیگری غیرزمینه‌ای. فرایند زمینه‌ای اعداد ۰ تا ۴ را چاپ می‌کند و فرایند غیرزمینه‌ای همزمان اعداد ۵ تا ۹ را تولید می‌کند. به دلیل اجرای موازی و تأخیرهای زمانی، خروجی‌های دو فرایند در هم تنیده می‌شوند و ترتیب ثابتی ندارند. در پایان، هر دو فرایند پیام خروج خود را ثبت می‌کنند. علت این خروجی اجرای همزمان دو فرایند و تداخل طبیعی زمان‌بندی سیستم‌عامل است.",
    (3, "3"): "در این کد دو فرایند به صورت ترتیبی اجرا می‌شوند. ابتدا فرایند زمینه‌ای شروع شده و اعداد ۰ تا ۴ را با تأخیر ثابت چاپ می‌کند و سپس پایان می‌یابد. پس از آن، فرایند غیرزمینه‌ای آغاز می‌شود و اعداد ۵ تا ۹ را تولید کرده و در پایان پیام خروج خود را ثبت می‌کند. خروجی هر فرایند به‌طور کامل و پشت سر هم دیده می‌شود، بدون آنکه درهم‌تنیدگی بین پیام‌ها رخ دهد. علت این نظم، اجرای سریالی هر فرایند با start() و join() جداگانه است.",
    (4, "1"): "در این کد یک فرایند ایجاد و اجرا می‌شود. بلافاصله پس از شروع، پیام «Starting function» چاپ می‌شود اما به دلیل اجرای دستور terminate() پیش از پایان، فرایند ناگهان متوقف می‌شود و پیام «Finished function» هیچ‌وقت ظاهر نمی‌شود. پس از آن، با join() وضعیت فرایند بررسی می‌شود؛ مقدار exitcode برابر -15 (سیگنال خاتمه) است که نشان می‌دهد فرایند توسط دستور توقف پایان یافته است. علت این خروجی، اجرای یک خواب طولانی در تابع و متوقف کردن اجباری فرایند قبل از کامل شدن آن است.",
    (4, "2"): "در این کد یک فرایند آغاز می‌شود و پس از چاپ «Starting function» وارد حلقه‌ی شمارش می‌شود. چون time.sleep(2) در برنامه‌ی اصلی قبل از terminate() قرار دارد، فرایند فرصت پیدا می‌کند چند عدد اول حلقه (اینجا تا ۳) را چاپ کند. سپس با terminate() متوقف می‌شود و ادامه‌ی شمارش و پیام «Finished function» اجرا نمی‌شوند. در نهایت، با join() وضعیت بررسی شده و کد خروج -15 نشان می‌دهد که فرایند با سیگنال خاتمه پایان یافته است. علت این خروجی توقف اجباری فرایند در میانه‌ی کار است.",
    (4, "3"): "در این کد یک فرایند ایجاد می‌شود و تا پایان طبیعی کارش ادامه می‌یابد. ابتدا پیام «Starting function» چاپ می‌شود، سپس در یک حلقه پنج عدد پیاپی همراه با تأخیر نمایش داده می‌شود و در پایان پیام «Finished function» ثبت می‌گردد. چون فرایند به صورت کامل اجرا شده و با موفقیت پایان یافته است، مقدار کد خروج (exitcode) برابر با 0 است. علت این خروجی اجرای کامل فرایند بدون توقف اجباری است.",
    (5, "1"): "در این کد ده فرایند به طور همزمان آغاز می‌شوند. هر فرایند بلافاصله متد run را اجرا کرده و پیام مخصوص به نام خود را در صف قرار می‌دهد، سپس با تأخیر ۰٫۵ ثانیه‌ای به کارش ادامه می‌دهد. چون همه فرایندها همزمان شروع شده‌اند، پیام‌های «called run method…» به صورت درهم‌تنیده و بدون ترتیب مشخص بین شماره‌ها ظاهر می‌شوند. علت این خروجی اجرای موازی فرایندها و زمان‌بندی غیرقطعی سیستم‌عامل است.",
    (5, "2"): "در این کد پنج فرایند یکی‌یکی اجرا می‌شوند. برای هر فرایند پس از start() بلافاصله join() فراخوانی شده است، بنابراین هر فرایند کامل می‌شود و سپس فرایند بعدی آغاز می‌گردد. به همین دلیل پیام‌های «called run method…» به ترتیب و پشت سر هم چاپ شده‌اند و هیچ‌گونه درهم‌تنیدگی یا جابه‌جایی در خروجی وجود ندارد. علت این نظم، اجرای ترتیبی فرایندهاست.",
    (5, "3"): "در این کد پنج فرایند همزمان آغاز می‌شوند و سپس در برنامه‌ی اصلی با ترتیب معکوس join() می‌شوند. همزمانی در شروع باعث می‌شود پیام‌های «called run method…» بر اساس زمان‌بندی سیستم‌عامل و بدون نظم مشخص در صف قرار گیرند. معکوس بودن ترتیب join() فقط تعیین می‌کند که والد منتظر کدام فرایندها بماند، اما روی زمان ثبت پیام‌ها اثری ندارد. بنابراین خروجی نهایی شامل پیام‌های همه فرایندهاست اما ترتیب آن‌ها غیرقطعی است. علت این وضعیت، اجرای همزمان فرایندها همراه با همگام‌سازی معکوس در والد است.",
    (6, "1"): "در این کد یک فرایند تولیدکننده و یک فرایند مصرف‌کننده همزمان روی یک صف مشترک کار می‌کنند. تولیدکننده هر بار یک عدد تصادفی در صف قرار می‌دهد و اندازه صف را گزارش می‌کند. مصرف‌کننده پس از وقفه کوتاه همان آیتم را از صف برمی‌دارد و پیام مربوطه را ثبت می‌کند. از آنجا که تولید و مصرف تقریباً با همان نرخ انجام می‌شود، اندازه صف معمولاً ۱ باقی می‌ماند و هر آیتم بلافاصله پس از اضافه شدن مصرف می‌شود. در پایان، وقتی تولیدکننده کارش تمام شد و مصرف‌کننده همه آیتم‌ها را برداشت، پیام «the queue is empty» چاپ می‌شود. علت این خروجی اجرای همزمان دو فرایند با هماهنگی از طریق صف مشترک است.",
    (6, "2"): "در این کد دو فرایند تولیدکننده به‌طور همزمان ده آیتم را در صف قرار می‌دهند. هر بار پس از افزودن یک آیتم، اندازه صف گزارش می‌شود و چون هنوز مصرف‌کننده فعال نیست، مقدار qsize به تدریج افزایش یافته و به ۱۰ می‌رسد. پس از پایان کار تولیدکننده‌ها، فرایند مصرف‌کننده شروع شده و همه‌ی آیتم‌ها را یکی‌یکی از صف برمی‌دارد و پیام مربوط به هر برداشت را ثبت می‌کند. در انتها، وقتی همه آیتم‌ها مصرف شدند، پیام «the queue is empty» نمایش داده می‌شود. علت این خروجی اجرای موازی چند تولیدکننده و سپس مصرف‌کننده‌ای است که بعد از آن‌ها وارد عمل می‌شود.",
    (6, "3"): "در این کد ابتدا فرایند تولیدکننده به‌تنهایی اجرا می‌شود و ۸ آیتم را با تأخیر تصادفی در صف می‌گذارد؛ به همین خاطر qsize پس از هر افزودن یکی‌یکی زیاد می‌شود و به ۸ می‌رسد. پس از پایان تولیدکننده، فرایند مصرف‌کننده شروع می‌شود و اقلام را با وقفه‌های کوتاه از صف برمی‌دارد و گزارش می‌کند. چون مصرف فقط بعد از اتمام تولید آغاز شده، خروجی‌ها دو بخش جدا دارد: ابتدا رشد پیاپی اندازهٔ صف همراه با پیام‌های «appended»، سپس برداشت‌های متوالی و در پایان پیام «the queue is empty». علت این الگو، اجرای ترتیبی فرایندها (اول تولید، سپس مصرف) با هماهنگی از طریق صف مشترک است.",
    (7, "1"): "در این کد دو فرایند روی یک Barrier(2) منتظر می‌مانند. هر کدام پس از رسیدن به مانع، تا رسیدن دیگری بلوکه می‌شود؛ وقتی هر دو رسیدند، همزمان عبور کرده و زمان فعلی را ثبت می‌کنند. به همین دلیل مهرِ زمانِ دو خروجی تقریباً یکسان است. ترتیب چاپ «p1» و «p2» قطعی نیست و به زمان‌بندی سیستم و تخلیه‌ی صف لاگ بستگی دارد. (قفلِ ارسال‌شده در امضاء استفاده نمی‌شود.)",
    (7, "2"): "در این کد دو فرایند بدون استفاده از Barrier اجرا می‌شوند. هر فرایند بلافاصله پس از شروع زمان فعلی را ثبت و چاپ می‌کند. چون هیچ مانعی برای همگام‌سازی وجود ندارد، اختلاف جزئی در زمان‌ها دیده می‌شود (در حد چند میلی‌ثانیه) که ناشی از تفاوت زمان‌بندی اجرای سیستم‌عامل است. ترتیب چاپ خروجی‌ها نیز ثابت نیست و ممکن است در هر اجرا جابه‌جا شود.",
    (7, "3"): "در این کد چهار فرایند اجرا می‌شوند: دو فرایند بدون Barrier و دو فرایند با Barrier. فرایندهای بدون Barrier بلافاصله زمان فعلی را ثبت کرده و چون محدودیتی ندارند، خروجی آن‌ها زودتر ظاهر می‌شود. در مقابل، دو فرایند دارای Barrier باید هر دو به مانع برسند تا همزمان آزاد شوند؛ به همین دلیل زمان ثبت‌شده برای آن‌ها یکسان است و کمی بعد از فرایندهای بدون Barrier چاپ می‌شود. ترتیب دقیق نمایش پیام‌ها نیز وابسته به زمان‌بندی سیستم‌عامل است.",
    (8, "1"): "در این کد یک استخر ۸‌فرایندی ساخته شده و با pool.map(square, numbers) روی اعداد ۰ تا ۹۹ اعمال می‌شود. map کارها را بین فرایندها توزیع می‌کند ولی ترتیب نتایج را همانند ترتیب ورودی حفظ می‌کند؛ به همین دلیل خروجی یک لیستِ مرتب از مربعات ۰ تا ۹۹ است. چون map بلوک‌کننده است، تا زمانی که همه‌ی کارها تمام نشوند چیزی چاپ نمی‌شود و در پایان یک‌باره کل لیست نتایج نمایش داده می‌شود.",
    (8, "2"): "در این کد از apply_async برای هر عدد استفاده شده است. هر فراخوانی یک شیء Future برمی‌گرداند و بعد با get() نتیجهٔ آن خوانده می‌شود. اگرچه کارها به شکل ناهمگام بین فرایندها توزیع می‌شوند، اما چون نتایج به ترتیب از لیست Futureها گرفته می‌شود، خروجی نهایی دوباره یک لیست مرتب از مربعات ۰ تا ۹۹ است. علت این خروجی آن است که گرفتن نتایج با get() ترتیب ورودی‌ها را حفظ می‌کند.",
    (8, "3"): "در این کد یک استخر ۸‌فرایندی ساخته شده و با pool.imap(square, numbers) روی اعداد ۰ تا ۹۹ کار می‌کند. imap نتایج را به‌ترتیب ورودی تولید می‌کند (جریان‌محور)، اما چون خروجی در پایان با list(...) جمع‌آوری شده، کل لیست مربعات ۰ تا ۹۹ یک‌جا چاپ شده است. اختلافی با map از نظر ترتیب دیده نمی‌شود؛ تفاوت اصلی این است که imap ذاتاً بازگشتی تنبل برمی‌گرداند و می‌تواند به‌صورت تدریجی مصرف شود.",
}


THREAD_FUNCS = {
    1: run_thread_question_1,
    2: run_thread_question_2,
    3: run_thread_question_3,
    4: run_thread_question_4,
    5: run_thread_question_5,
    6: run_thread_question_6,
    7: run_thread_question_7
}

PROCESS_FUNCS = {
    1: run_process_question_1,
    2: run_process_question_2,
    3: run_process_question_3,
    4: run_process_question_4,
    5: run_process_question_5,
    6: run_process_question_6,
    7: run_process_question_7,
    8: run_process_question_8
}


def get_thread_explanation(question: int, scenario: str) -> str:
    return EXPLANATIONS_THREAD.get((question, scenario), "توضیحی برای این ابزار/سناریو ثبت نشده است.")

def get_process_explanation(question: int, scenario: str) -> str:
    return EXPLANATIONS_PROCESS.get((question, scenario), "توضیحی برای این ابزار/سناریو ثبت نشده است.")

def run_and_capture(func, scenario: str):
    import io, logging
    from contextlib import redirect_stdout, redirect_stderr

    buffer = io.StringIO()

    # هندلر موقت برای logging (root logger)
    handler = logging.StreamHandler(buffer)
    handler.setFormatter(logging.Formatter(
        "%(asctime)s %(threadName)-17s %(levelname)-8s %(message)s"
    ))
    logger = logging.getLogger()
    prev_level = logger.level
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)

    try:
        with redirect_stdout(buffer), redirect_stderr(buffer):
            func(scenario)
    finally:
        handler.flush()
        logger.removeHandler(handler)
        logger.setLevel(prev_level)

    return buffer.getvalue().splitlines()


@app.get("/thread/{question}")
def run_thread(question: int, scenario: str = Query(..., description="1|2|3")):
    func = THREAD_FUNCS.get(question)
    if not func:
        return {"mode": "thread", "question": question, "error": "سؤال نامعتبر است."}
    lines = run_and_capture(func, scenario)
    explanation = get_thread_explanation(question, scenario)
    return {
        "mode": "thread",
        "question": question,
        "scenario": scenario,
        "output": lines,
        "explanation": explanation,
        "status": "OK"
    }


@app.get("/process/{question}")
def run_process(question: int, scenario: str = Query(..., description="1|2|3")):
    func = PROCESS_FUNCS.get(question)
    if not func:
        return {"mode": "process", "question": question, "error": "سؤال نامعتبر است."}
    lines = run_and_capture(func, scenario)
    explanation = get_process_explanation(question, scenario)
    return {
        "mode": "process",
        "question": question,
        "scenario": scenario,
        "output": lines,
        "explanation": explanation,
        "status": "OK"
    }
